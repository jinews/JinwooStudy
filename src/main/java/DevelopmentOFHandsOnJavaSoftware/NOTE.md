
# 입출금 내역 분석기 요구사항

 >- 은행 입출금 내역의 총 수입과 총 지출은 각각 얼마인가? (결과가 음수인지 양수인지)   
 >- 특정 달엔 몇 건의 입출금 내역이 발생하였는지?
 >- 지출이 가장 높은 상위 10건은 무엇인지
 >- 돈을 가장 많이 소비하는 항목은 무엇인지

# KISS 원칙
 >keep it short and simple

## 코드유지 보수성 ( code maintainability )
 >- 특정 기능을 담당하는 코드를 쉽게 찾을 수 있어야한다
 >- 코드가 어떤 일을 수행하는지 쉽게 이해할 수 있어야한다.
 >- 새로운 기능을 쉽게 추가하거나 기존 기능을 쉽게 제거할 수 있어야 한다.
 >- 캡슐화 (encapsulation)가 잘 되어 있어야 한다.
 코드 사용자에게는 세부 구현 내용이 감춰져 있으므로 사용자가 쉽게 코드를 이해하고, 기능을 바꿀 수 있어야 한다.

# 안티패턴 ( 좋지않은 패턴들 = 피해야하는 패턴 )
### 갓 클래스
   >한 클래스로 모든것을 다 해결하는 패턴 이런 패턴을 `" 갓 클래스 안티 패턴 "` 이라고 부른다.
### 코드 중복 ( don't repeat yourself(DRY) `중복배제 원칙 `)
   >- 기능이 추가 될때마다 한 가지의 문제만 해결하도록(하드코딩) 작성하면 기존의 기능을 바꾸기 어렵다.
   >- 모든 곳의 코드를 바꿔야하며, 새로운 버그가 발생할 가능성이 커짐

# 단일 책임의 원칙 (`SRP` / single responsibility principle)
  >- 한 클래스는 한 기능만 책임진다.
  >- 클래스가 바뀌어야 하는 이유는 오직 하나여야 한다.
  >- 주로 클래스와 메서드에 적용

##  분리 예시
  >1. 입력 읽기
  >2. 주어진 형시긔 입력 파싱
  >3. 결과 처리
  >4. 결과 요약 리포트

## 놀람 최소화 원칙 ( principle of least surprise )
  >- 일관성을 유지하는 범위에서 코드를 구현할 것을 강조하는 원칙
  >- 어떤 메서드가 다른 메서들과 달리 예상치 못하는 방법으로 동작한다면 코드를 이해하기 힘듬
  >- 메서드가 수행하는 일을 바로 이해할 수 있도록 자체 문서화를 제공하는 메서드명 사용
  >- 코드의 다른 부분이 파라미터의 상태에 의존할 수 있으므로 파라미터의 상태를 바꾸지 않음

## 원칙 요약
  >- `KISS` (keep it short and simple) = 짧고 간결한 코드
  >- `DRY` (don't repeat yourself) = 중복 배제
  >- `SRP` (single responsibility principle) = 단일 책임의 원칙

# 응집도 ( cohesion ) == "서로 어떻게 관련 되어있는지"
  >- 코드 유지 보수성을 결정하는 중요한 개념 ( 소프트웨어의 복잡성을 유추하는 데 도움을 준다 )
  >- 클래스나 메서드의 책임이 서로 얼마나 강하게 연결되어 있는지를 측정한다.

## 프로그램의 진입점 ( entry point ) == mainClass?

- - - 

# 클래스 수준 응집도
##  실무에서는 일반적으로 다움과 같은 여섯가지 방법으로 그룹화 (기능, 정보, 유틸리티, 논리, 순차, 시간 )
### 1. 기능
>- 기능이 비슷한 메서드를 그룹화
>- 함께 사용하는 메서드를 그룹화 하면 찾기도 쉽고 이해하기도 쉬우므로 응집도를 높힌다.
>- 다만 기능 응집은 한 개의 메서드를 갖는 클래스를 너무 과도하게 만들려는 경향이 발생할 수 있는 약점이 있음

### 2. 정보
>- 같은 데이터나 `도메인 객체`를 처리하는 메서드를 그룹화 하는 방법
>- `CRUD`(create, read, update, delect)를 사용하여 관련된 데이터를 응집하는 방식을 에로들 수 있음 
>- `데이터 접근 객체 DAO` ( data access object ) 테이블이나 특정 도메인 객체를 저장하는 데이터 베이스와 상호작용시 사용

### 3. 유틸리티
>- 관련성 없는 메서드를 한 클래스로 포함시켜야 할떄 ( 어디에 속해야할지 결정하기 어려울떄 )
>- 낮은 응집도로 이어지므로 자제해야하며, 메서드의 연관성이 없어 클래스의 전체 기능을 추론하기 어려움
### 4. 논리
>- 이해를 위한 예시 / 파싱이라는 xml, json, csv의 자료를 "파싱" 한다는 논리로 그룹화
>- 이렇게 되면 3가지 책임을 가져야 하므로 단일책임원칙인 SRP를 위배 하게된다.

### 5. 순차
>- 데이터를 요구사항에 맞춰 가공하는 순서로 메서드를 한 클래스로 그룹화하는것
>- 순차응집은 여러 동작이 어떻게 함께 수행되는지 쉽게 이해할 수 있다. 
>- 하지만 순차응집은 한 클래스를 바꿔야할 여러 이유가 존재하여 SRP(단일책임원칙)을 위배한다
### 6. 시간
>- 시간과 연관된 연산을 그룹화
>- 예시 / 어떤 처리 작업을 `시작하기 전과 뒤에 초기화`, 뒷정리 작업 ( 데이터베이스 연결과 종료 )을 담당하는 메서드를 포함한 클래스

# 응집도 수준과 장단점 표

| 응집도 수준           | 장점              | 단점                     |
|------------------|-----------------|------------------------|
| 기능 (높은 응집도)      | 이해하기 쉬움         | 너무 단순한 클래스 생성          |
| 정보 (중간 응집도)      | 유지보수하기 쉬움       | 불필요한 디펜던시(의존성)         |
| 순차 (중간 응집도)      | 관련 동작을 찾기 쉬옴    | SRP(단일책임원칙)를 위배할 수 있음  |
| 논리 (중간 응집도)      | 높은 수준의 카테고리화 제공 | SRP(단일책임원칙)를 위배할 수 있음  |
| 유틸리티 (낮은 응집도)    | 간단히 추가 가능       | 클래스의 책임을 파아가기 어려움      |
| 시간 (낮은 응집도)      | 판단 불가           | 각 동작을 이해하고 사용하기 어려움    |

## 메서드 수준의 응집도
>- 응집도는 클래스만 해당하는 것이 아니고 메서드에도 해당함
>- 메서드가 다양한 기능을 수행할수록 메서드가 어떤 동작을 하는지 이해하기 힘들어짐
>>- 여러 책임을 포함하기 떄문에 각 책임을 테스트하기 어려워짐
>>- 일반적으로 클래스나 메서드 파라미터의 여러 필드를 바꾸는 if/else 블록이 여러개라면 응집도에 문제가 있음

# 결합도 ( coupling ) != 분리된 ( decoupled )
  >- 한 기능이 다른 클래스에 얼마나 의존하고 있는지를 가늠하는것
  >- 어떤 클래스를 구현하는 데 얼마나 많은 지식(다른 클래스)을 참조했는가로 설명할 수 있다. 
  >- 많은 클래스를 참조했다면 기능을 변경할 떄 유연성이 떨어진다.
- - -
# 테스트
>코드가 잘 동작하는지, 고객의 요구 사항을 충족 했음을 무엇으로 보장할 수 있을지 확인하는 방법

## 테스트 자동화
### 자동화된 테스트에서는 사람의 조작없이 여러 테스트가 포함된 suite가 작동된다.
>- "Test Suite"의 suite는 직역하면 "제품군"이지만 소프트웨어에서는 "여러 테스트를 묶어놓은 집합"으로 해석한다.
>- "Test CASE" 개별적인 테스트 시나리오, 항목 //  "Test Suite": 관련된 여러 테스트 케이스들을 논리적으로 묶어놓은 그룹
### "Test Suite"의 장점
> - 관련된 테스트들을 체계적으로 관리할 수 있음
> - 한 번의 실행으로 여러 테스트를 자동으로 수행할 수 있음
> - 테스트 결과를 그룹 단위로 확인할 수 있음

## 테스트 자동화의 장점 
### 확신 : 소프트웨어가 규격 사양과 일치하며 동작하는지, 고객의 요구 사항을 충족하고 있다는 것을 확신하는것
>- 테스트 규격 사양과 결과를 고객에게 증거로 제공할 수도 있다 == 테스트가 고객의 사양이 된다.
>- 변화에도 튼튼함을 유지 코드양이 많았을때, 수정을 하게되면 문제가 발생하지 않을 거라는 확신할 수 없지만,
   "Test Suite"가 있다면 `버그가 발생하지 않았음을 확인하는 지표`가 될 수 있다.
>- 프로그램 이해도 : 프로젝트에서 다양한 `컴포넌트가 어떻게 동작`하는지 이해하는데 도움을 준다
>>- 테스트는 다양한 컴포넌트의 디펜던시와 이들이 어떻게 상호작용하는지를 명확하게 드러낸다.
>>- 따라서 소프트웨어의 전체 개요를 빨리 파악할 수 있음.
>>- 새 프로젝트 투입시 컴포넌트의 개요를 살펴 보려면 `자동화된 테스트`를 먼저 살펴보면 좋다.

## 유닛 테스트 : 메서드나 작은 클래스처럼 작고 고립된 단위를 테스트 하는 것
> 유닛 테스트의 세 단계 패턴 **`Given - When - Then`** 공식이라 부름
### Given ( 준비단계 )
>- #### 테스트 환경과 조건을 설정하는 단계.   
>> 테스트 하려는 코드가 예상된 상태로 동작할 수 있도록 필요한 객체를 초기화 하거나 입력 데이터 준비.
>- #### 메서드의 필요한 `매개변수를 설정`하거나, 의존하는 객체를 설정하고 `모의 객체`를 준비하는 과정포함.
### When ( 실행단계 )
>- 실제로 테스트할 동작을 수행하는 단계
>- 특정 메서드 호출, 입력 데이터 처리과정 실행
### Then ( 검증단계 )
>- 실행결과를 검증하는 단계
>- `asser`문을 사용하여 실제 결과가 기댓값과 일치하는지 확인하는 단계
>- 반환값이 예상한 값인지, 특정 예외가 발생했는지, 객체의 상태가 예상대로 변화했는지 확인

## Assertion construction
| Assertion construction                         | purpose                              |
|------------------------------------------------|--------------------------------------|
| Assert.fail( massage )                         | 메서드 실행 결과                            |
| Assert.assertEquals( expected, actual )        | 두값이 같은지 테스트                          |
| Assert.assertEquals( expected, actual, delta ) | 두 float나 double이 delta 범위 내에서 같은지 테스트 |
| Assert.assertNotNull(object)                   | 객체가 null이 아닌지 테스트                    |

## 코드 커버리지 ( Code coverage )
>- 테스트 집합이 소프트웨어의 소스코드를 얼마나 테스트했는가를 가리키는 척도.
>- `coverage`가 높을수록 버그 활생 확률이 낮아짐 그래서 coverage 를 높이는 것을 목표로 삼아야한다.

# 2장 정리
>- `갓 클래스와 코드 중복`은 코드를 추론하고 유지보수하기 어렵게 만드는 요인.
>- `단일 책임 원칙`은 관리하고 유지보수하기 쉬운 코드를 구현하는 데 도움을 준다.
>- `응집도`는 클래스나 메서드의 책임이 얼마나 강하게 연관되어 있는지를 가리킨다.
>- `결합도`는 클래스가 다른 코드 부분에 얼마나 의존하고 있는지를 가리킨다.
>- `높은 응집도와 낮은 결합도`는 유지보수가 가능한 코드가 가져야 할 특성이다.
>- `자동화된 테스트 스위트`는 소프트웨어가 올바로 동작하며, 코드를 수정해도 잘 동작할 것임을 확신할 수 있고, 프로그램을 쉽게 이해할 수 있도록 도움을 준다.
